{"version":3,"sources":["webpack:///./dynamic-slider/src/common/customEvents.js","webpack:///./dynamic-slider/src/index.js"],"names":["CustomEventsCollection","dataJSON","params","defaultParams","CustomEvent","sliderStart","sliderMove","sliderStop","bubbles","composed","DynamicSlider","html","handlePositionX","undefined","handlePositionY","parentBoundaries","isSliderShown","e","__isShowSlider","shadowRoot","querySelector","getBoundingClientRect","setDefaultHandlePosition","val","__adjustedPts","handleRadius","imageHandle","querySelectorAll","imgHandle","setAttributeNS","localX","detail","x","left","localY","y","top","__lineParam","x_min","x_max","m","b","currentDistance","calculateDistance","from","data","proportion","__length","state","dispatchEvent","ce","sliderStartObj","sliderMoveObj","sliderStopObj","lineThickness","__pt1","__pt2","xOffset","yOffset","x1","y1","x2","y2","to","bSanityCheck","compareSensitivity","sanityCheckDiff","Math","abs","__drawStartPt","lineColor","__overlayThickness","handleColor","style","width","height","sqrt","type","Number","value","String","computed","Object","Boolean","__width","__height","__containerStyle","__trackStyle","__trackOverlayStyle","__circleHandleStyle","__imgHandleStyle","__imgHandleSize","PolymerElement","window","customElements","define","is"],"mappings":"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","file":"dynamic-slider.bundle.js","sourcesContent":["class CustomEventsCollection {\n  constructor() {}\n\n  static get sliderStart() {\n    return \"slider-start\";\n  }\n\n  static get sliderMove() {\n    return \"slider-move\";\n  }\n\n  static get sliderStop() {\n    return \"slider-stop\";\n  }\n\n  static get defaultParams() {\n    return {bubbles: true, composed: true};\n  }\n\n  static sliderStartObj(dataJSON=null) {\n    let params = Object.assign({}, this.defaultParams, {\"detail\": dataJSON});\n    return new CustomEvent(this.sliderStart, params);\n  }\n\n  static sliderMoveObj(dataJSON=null) {\n    let params = Object.assign({}, this.defaultParams, {\"detail\": dataJSON});\n    return new CustomEvent(this.sliderMove, params);\n  }\n\n  static sliderStopObj(dataJSON=null) {\n    let params = Object.assign({}, this.defaultParams, {\"detail\": dataJSON});\n    return new CustomEvent(this.sliderStop, params);\n  }\n}\n\nexport default CustomEventsCollection;\n","import {PolymerElement} from '@polymer/polymer/polymer-element.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\nimport '@polymer/polymer/lib/elements/dom-if.js';\nimport {GestureEventListeners} from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport ce from './common/customEvents.js';\n\n/**\n * `dynamic-slider`\n * Renders a slider between any 2 arbitrary points on the screen.\n *\n * @customElement\n * @polymer\n * @demo demo/index.html\n */\nclass DynamicSlider extends GestureEventListeners(PolymerElement) {\n  static get template() {\n    return html `\n      <style>\n        :host {\n          pointer-events: none;\n          display: block;\n          height: auto;\n          width: auto;\n          position: absolute;\n        }\n      </style>\n      <template is=\"dom-if\" if=\"[[__isShowSlider]]\" on-dom-change=\"displayChange\">\n        <svg id=\"container\"\n             width$=\"[[__width]]\"\n             height$=\"[[__height]]\"\n             style$=\"[[__containerStyle]]\">\n          <line id=\"track\"\n                x1$=\"[[__adjustedPts.from.x]]\"\n                y1$=\"[[__adjustedPts.from.y]]\"\n                x2$=\"[[__adjustedPts.to.x]]\"\n                y2$=\"[[__adjustedPts.to.y]]\"\n                style$=\"[[__trackStyle]]\" />\n          <line id=\"track-overlay\"\n                x1$=\"[[__adjustedPts.from.x]]\"\n                y1$=\"[[__adjustedPts.from.y]]\"\n                x2$=\"[[__adjustedPts.to.x]]\"\n                y2$=\"[[__adjustedPts.to.y]]\"\n                style$=\"[[__trackOverlayStyle]]\"\n                on-track=\"adjustHandle\" />\n          <circle id=\"handle-circle\"\n                  style$=\"[[__circleHandleStyle]]\"\n                  r$=\"[[handleRadius]]\"\n                  cx$=\"[[handlePositionX]]\"\n                  cy$=\"[[handlePositionY]]\"></circle>\n          <image id=\"handle-img\"\n                 preserveAspectRatio=\"xMidYMid meet\"\n                 width$=\"[[__imgHandleSize.width]]\"\n                 height$=\"[[__imgHandleSize.height]]\"\n                 x$=\"[[handlePositionX]]\"\n                 y$=\"[[handlePositionY]]\"\n                 style$=\"[[__imgHandleStyle]]\" />\n           </svg>\n        </svg>\n      </template>\n      `;\n  }\n\n  constructor() {\n    super();\n    this.handlePositionX = undefined;\n    this.handlePositionY = undefined;\n    this.parentBoundaries = undefined;\n    this.isSliderShown = false;\n  }\n\n  displayChange(e) {\n    if (!this.__isShowSlider) {\n      this.isSliderShown = false;\n      return;\n    }\n    this.isSliderShown = true;\n    // Update the objective location offset for this element.\n    this.parentBoundaries = this.shadowRoot.querySelector(\"#container\").getBoundingClientRect();\n    // Update the current handle position\n    this.setDefaultHandlePosition(this.val, this.__adjustedPts, this.handleRadius);\n    // Find the image handle, if is available, then set the image for it.\n    let imageHandle = this.shadowRoot.querySelectorAll(`#handle-img:not([style*=\"display:none\"]):not([style*=\"display: none\"])`)[0];\n    if (imageHandle && this.imgHandle) {\n      imageHandle.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.imgHandle);\n    }\n  }\n\n  adjustHandle(e) {\n    if (!this.parentBoundaries) {\n      return;\n    }\n    let localX = e.detail.x - this.parentBoundaries.left;\n    let localY = e.detail.y - this.parentBoundaries.top;\n    // Use the simplified expression for getting the intersecting line's point intersection\n    // between localX/Y and the slider line to find out where to place the handle on the\n    // slider. Clamp the values with the given x_min and x_max values.\n    this.handlePositionX = (localX < this.__lineParam.x_min)\n      ? this.__lineParam.x_min\n      : (localX > this.__lineParam.x_max)\n        ? this.__lineParam.x_max\n        : (localX + (this.__lineParam.m * (localY - this.__lineParam.b))) / (this.__lineParam.m**2 + 1);\n    this.handlePositionY = (this.__lineParam.m * this.handlePositionX) + this.__lineParam.b;\n    // Calculate the proportion between the current handle position and slider's length.\n    let currentDistance = this.calculateDistance(this.__adjustedPts.from.x,\n                                                 this.__adjustedPts.from.y,\n                                                 this.handlePositionX,\n                                                 this.handlePositionY);\n    // If an image handle is being used, offset the position to the image center\n    if (this.imgHandle) {\n      this.handlePositionX -= this.handleRadius;\n      this.handlePositionY -= this.handleRadius;\n    }\n    let data = {\n      proportion: currentDistance / this.__length\n    };\n    switch(e.detail.state) {\n      case \"start\":\n        this.shadowRoot.querySelector(\"#container\").dispatchEvent(ce.sliderStartObj(data));\n        break;\n      case \"track\":\n        this.shadowRoot.querySelector(\"#container\").dispatchEvent(ce.sliderMoveObj(data));\n        break;\n      case \"end\":\n        this.shadowRoot.querySelector(\"#container\").dispatchEvent(ce.sliderStopObj(data));\n        break;\n    }\n  }\n\n  static get is() {\n    return 'dynamic-slider';\n  }\n\n  static get properties() {\n    return {\n      lineThickness: {\n        type: Number,\n        value: 2\n      },\n      lineColor: {\n        type: String,\n        value: \"black\"\n      },\n      handleRadius: {\n        type: Number,\n        value: 8\n      },\n      handleColor: {\n        type: String,\n        value: \"black\"\n      },\n      x1: Number,\n      y1: Number,\n      x2: Number,\n      y2: Number,\n      val: Number,\n      imgHandle: {\n        type: String,\n        value: \"\"\n      },\n      __overlayThickness: {\n        type: Number,\n        computed: \"computeOverlayThickness(lineThickness)\"\n      },\n      __pt1: {\n        type: Object,\n        computed: \"computePoint(x1, y1)\"\n      },\n      __pt2: {\n        type: Object,\n        computed: \"computePoint(x2, y2)\"\n      },\n      __isShowSlider: {\n        type: Boolean,\n        computed: \"computeIsShowSlider(__pt1, __pt2)\"\n      },\n      __drawStartPt: {\n        type: Object,\n        computed: \"computeDrawStartPoint(__isShowSlider, handleRadius, __pt1, __pt2)\"\n      },\n      __adjustedPts: {\n        type: Object,\n        computed: \"computeAdjustedPoints(__isShowSlider, handleRadius, __pt1, __pt2)\"\n      },\n      __length: {\n        type: Number,\n        computed: \"computeDistance(__adjustedPts)\"\n      },\n      __lineParam: {\n        type: Object,\n        computed: \"computeLineParam(__adjustedPts)\"\n      },\n      __width: {\n        type: Number,\n        computed: \"computeWidth(__isShowSlider, handleRadius, __pt1, __pt2)\"\n      },\n      __height: {\n        type: Number,\n        computed: \"computeHeight(__isShowSlider, handleRadius, __pt1, __pt2)\"\n      },\n      __containerStyle: {\n        type: String,\n        computed: \"computeContainerStyle(__drawStartPt)\"\n      },\n      __trackStyle: {\n        type: String,\n        computed: \"computeTrackStyle(lineThickness, lineColor)\"\n      },\n      __trackOverlayStyle: {\n        type: String,\n        computed: \"computeTrackOverlayStyle(__overlayThickness)\"\n      },\n      __circleHandleStyle: {\n        type: String,\n        computed: \"computeCircleHandleStyle(imgHandle, handleColor)\"\n      },\n      __imgHandleStyle: {\n        type: String,\n        computed: \"computeImageHandleStyle(imgHandle)\"\n      },\n      __imgHandleSize: {\n        type: Object,\n        computed: \"computeImageHandleSize(handleRadius)\"\n      }\n    };\n  }\n\n  static get observers() {\n    return [\n      \"setDefaultHandlePosition(val, __adjustedPts, handleRadius)\"\n    ];\n  }\n\n  computeOverlayThickness(lineThickness) {\n    return lineThickness * 6;\n  }\n\n  computePoint(x, y) {\n    return (x !== undefined && y !== undefined && !Number.isNaN(x) && !Number.isNaN(y))\n      ? { x, y }\n      : undefined;\n  }\n\n  computeIsShowSlider(__pt1, __pt2) {\n    return __pt1 !== undefined && __pt2 !== undefined;\n  }\n\n  computeDrawStartPoint(__isShowSlider, handleRadius, __pt1, __pt2) {\n    return (__isShowSlider)\n      ? {\n        x: ((__pt2.x <= __pt1.x) ? __pt2.x : __pt1.x) - handleRadius,\n        y: ((__pt2.y <= __pt1.y) ? __pt2.y : __pt1.y) - handleRadius\n      }\n      : undefined;\n  }\n\n  computeAdjustedPoints(__isShowSlider, handleRadius, __pt1, __pt2) {\n    if (!__isShowSlider) {\n      return;\n    }\n    let xOffset = (__pt1.x <= __pt2.x) ? __pt1.x : __pt2.x;\n    let yOffset = (__pt1.y <= __pt2.y) ? __pt1.y : __pt2.y;\n    let x1 = (__pt1.x - xOffset) + handleRadius;\n    let y1 = (__pt1.y - yOffset) + handleRadius;\n    let x2 = (__pt2.x - xOffset) + handleRadius;\n    let y2 = (__pt2.y - yOffset) + handleRadius;\n    return {\n      from: { x: x1, y: y1 },\n      to: { x: x2, y: y2 }\n    };\n  }\n\n  computeDistance(__adjustedPts) {\n    if (!__adjustedPts) {\n      return;\n    }\n    return this.calculateDistance(__adjustedPts.from.x, __adjustedPts.from.y, __adjustedPts.to.x, __adjustedPts.to.y);\n  }\n\n  computeLineParam(__adjustedPts) {\n    if (!__adjustedPts) {\n      return;\n    }\n    let m = (__adjustedPts.to.y - __adjustedPts.from.y) / (__adjustedPts.to.x - __adjustedPts.from.x);\n    let b = __adjustedPts.to.y - (m * __adjustedPts.to.x);\n    let bSanityCheck = __adjustedPts.from.y - (m * __adjustedPts.from.x);\n    let compareSensitivity = 1e-6;\n    let sanityCheckDiff = Math.abs(b - bSanityCheck);\n    if (sanityCheckDiff > compareSensitivity) {\n      throw `Something went wrong while extrapolating linear parameters from dynamic slider.\\nPoints: from (${__adjustedPts.from.x}, ${__adjustedPts.from.y}) to (${__adjustedPts.to.x}, ${__adjustedPts.to.y}).\\nSanity check diff: ${sanityCheckDiff}, sensitivity: ${compareSensitivity}.`;\n    }\n    let x_min = __adjustedPts.from.x;\n    let x_max = __adjustedPts.to.x;\n    if (__adjustedPts.to.x < __adjustedPts.from.x) {\n      x_min = __adjustedPts.to.x;\n      x_max = __adjustedPts.from.x;\n    }\n    return { m, b, x_min, x_max };\n  }\n\n  computeWidth(__isShowSlider, handleRadius, __pt1, __pt2) {\n    return (__isShowSlider)\n      ? Math.abs(__pt1.x - __pt2.x) + (2 * handleRadius)\n      : undefined;\n  }\n\n  computeHeight(__isShowSlider, handleRadius, __pt1, __pt2) {\n    return (__isShowSlider)\n      ? Math.abs(__pt1.y - __pt2.y) + (2 * handleRadius)\n      : undefined;\n  }\n\n  computeContainerStyle(__drawStartPt) {\n    return (__drawStartPt)\n    ? `\n      pointer-events: none;\n      transform: translate(${__drawStartPt.x}px, ${__drawStartPt.y}px);\n    `\n    : undefined;\n  }\n\n  computeTrackStyle(lineThickness, lineColor) {\n    return `\n      pointer-events: none;\n      stroke: ${lineColor};\n      stroke-width: ${lineThickness}px;\n      stroke-linecap: round;\n    `;\n  }\n\n  computeTrackOverlayStyle(__overlayThickness) {\n    return `\n      pointer-events: stroke;\n      cursor: pointer;\n      stroke-width: ${__overlayThickness}px;\n      stroke-linecap: round;\n\n    `;\n  }\n\n  computeCircleHandleStyle(imgHandle, handleColor) {\n    let style = `\n      fill: ${handleColor};\n    `;\n    style += (!imgHandle) ? `` : `display: none;`;\n    return style;\n  }\n\n  computeImageHandleStyle(imgHandle) {\n    let style = ``;\n    style += (!imgHandle) ? `display: none;` : ``;\n    return style;\n  }\n\n  computeImageHandleSize(handleRadius) {\n    return {\n      width: 2 * handleRadius,\n      height: 2 * handleRadius\n    };\n  }\n\n  setDefaultHandlePosition(val, __adjustedPts, handleRadius) {\n    // If the reference points do not exist, do nothing.\n    if (!__adjustedPts || !this.isSliderShown) {\n      return;\n    }\n    if (val !== undefined && !Number.isNaN(val) && val >= 0 && val <= 1) {\n      // If user provided an input value and that value is in a valid range (0 - 1),\n      // set the handle to that value. When handle position change, emit an event\n      // to notify the change.\n      this.handlePositionX = __adjustedPts.from.x + (val * (__adjustedPts.to.x - __adjustedPts.from.x));\n      this.handlePositionY = __adjustedPts.from.y + (val * (__adjustedPts.to.y - __adjustedPts.from.y));\n      this.shadowRoot.querySelector(\"#container\").dispatchEvent(ce.sliderMoveObj({ proportion: val }));\n    } else {\n      // Assign default location of the handlers to be the starting point\n      this.handlePositionX = this.handlePositionX || __adjustedPts.from.x;\n      this.handlePositionY = this.handlePositionY || __adjustedPts.from.y;\n    }\n    // If an image handle is being used, offset the position to the image center\n    if (this.imgHandle) {\n      this.handlePositionX -= handleRadius;\n      this.handlePositionY -= handleRadius;\n    }\n  }\n\n  calculateDistance(x1, y1, x2, y2) {\n    return Math.sqrt((x1 - x2)**2 + (y1 - y2)**2);\n  }\n}\n\nwindow.customElements.define(DynamicSlider.is, DynamicSlider);\n"],"sourceRoot":""}